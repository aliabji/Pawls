{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport _pt from \"prop-types\";\nimport _ from 'lodash';\nimport React, { Component } from 'react';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport { Colors } from \"../../style\";\nimport { Constants, asBaseComponent } from \"../../commons/new\";\nimport { LogService } from \"../../services\";\nimport View from \"../view\";\nimport ScrollBar from \"../scrollBar\";\nimport TabBarItem from \"./TabBarItem\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar MIN_TABS_FOR_SCROLL = 1;\nvar DEFAULT_BACKGROUND_COLOR = Colors.white;\nvar DEFAULT_HEIGHT = 48;\n\nvar TabBar = function (_Component) {\n  _inherits(TabBar, _Component);\n\n  var _super = _createSuper(TabBar);\n\n  function TabBar(_props) {\n    var _this;\n\n    _classCallCheck(this, TabBar);\n\n    _this = _super.call(this, _props);\n\n    _this.shouldBeMarked = function (index) {\n      return _this.state.currentIndex === index && !_this.isIgnored(index) && _this.childrenCount > 1;\n    };\n\n    _this.onItemPress = function (index, props) {\n      _this.updateIndicator(index);\n\n      setTimeout(function () {\n        if (!props.ignore) {\n          _this.onChangeIndex(index);\n        }\n\n        _this.onTabSelected(index);\n\n        props.onPress == null ? void 0 : props.onPress();\n      }, 0);\n    };\n\n    _this.onScroll = function (event) {\n      var contentOffset = event.nativeEvent.contentOffset;\n      _this.contentOffset = contentOffset;\n    };\n\n    _this.onContentSizeChange = function (width) {\n      if (_this.scrollContentWidth !== width) {\n        _this.scrollContentWidth = width;\n        var minTabsForScroll = _this.props.minTabsForScroll;\n        var minChildrenCount = minTabsForScroll || MIN_TABS_FOR_SCROLL;\n\n        if (_this.hasOverflow() && _this.childrenCount > minChildrenCount) {\n          _this.setState({\n            scrollEnabled: true\n          });\n        }\n      }\n    };\n\n    _this.state = {\n      scrollEnabled: false,\n      currentIndex: _props.selectedIndex || 0\n    };\n    _this.contentOffset = {\n      x: 0,\n      y: 0\n    };\n    _this.scrollBar = React.createRef();\n    _this.itemsRefs = [];\n    LogService.componentDeprecationWarn({\n      oldComponent: 'TabBar',\n      newComponent: 'TabController'\n    });\n    return _this;\n  }\n\n  _createClass(TabBar, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var prevChildrenCount = React.Children.count(prevProps.children);\n\n      if (this.childrenCount !== prevChildrenCount) {\n        this.updateIndicator(0);\n      }\n\n      var isIndexManuallyChanged = this.props.selectedIndex !== prevState.currentIndex && prevProps.selectedIndex !== this.props.selectedIndex;\n\n      if (isIndexManuallyChanged) {\n        this.updateIndicator(this.props.selectedIndex);\n      }\n    }\n  }, {\n    key: \"childrenCount\",\n    get: function get() {\n      return React.Children.count(this.props.children);\n    }\n  }, {\n    key: \"scrollContainerWidth\",\n    get: function get() {\n      return this.props.containerWidth || Constants.screenWidth;\n    }\n  }, {\n    key: \"isIgnored\",\n    value: function isIgnored(index) {\n      var child = React.Children.toArray(this.props.children)[index];\n      return _.get(child, 'props.ignore');\n    }\n  }, {\n    key: \"hasOverflow\",\n    value: function hasOverflow() {\n      return this.scrollContentWidth && this.scrollContentWidth > this.scrollContainerWidth;\n    }\n  }, {\n    key: \"updateIndicator\",\n    value: function updateIndicator(index) {\n      var _this2 = this;\n\n      if (index !== undefined && !this.isIgnored(index)) {\n        this.setState({\n          currentIndex: index\n        }, function () {\n          _this2.scrollToSelected();\n        });\n      }\n    }\n  }, {\n    key: \"scrollToSelected\",\n    value: function scrollToSelected() {\n      var animated = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var childRef = this.itemsRefs[this.state.currentIndex];\n      var childLayout = childRef.getLayout();\n\n      if (childLayout && this.hasOverflow()) {\n        if (childLayout.x + childLayout.width - this.contentOffset.x > this.scrollContainerWidth) {\n          var _this$scrollBar, _this$scrollBar$curre;\n\n          (_this$scrollBar = this.scrollBar) == null ? void 0 : (_this$scrollBar$curre = _this$scrollBar.current) == null ? void 0 : _this$scrollBar$curre.scrollTo == null ? void 0 : _this$scrollBar$curre.scrollTo({\n            x: childLayout.x - this.scrollContainerWidth + childLayout.width,\n            y: 0,\n            animated: animated\n          });\n        } else if (childLayout.x - this.contentOffset.x < 0) {\n          var _this$scrollBar2, _this$scrollBar2$curr;\n\n          (_this$scrollBar2 = this.scrollBar) == null ? void 0 : (_this$scrollBar2$curr = _this$scrollBar2.current) == null ? void 0 : _this$scrollBar2$curr.scrollTo == null ? void 0 : _this$scrollBar2$curr.scrollTo({\n            x: childLayout.x,\n            y: 0,\n            animated: animated\n          });\n        }\n      }\n    }\n  }, {\n    key: \"onChangeIndex\",\n    value: function onChangeIndex(index) {\n      var _this$props$onChangeI, _this$props;\n\n      (_this$props$onChangeI = (_this$props = this.props).onChangeIndex) == null ? void 0 : _this$props$onChangeI.call(_this$props, index);\n    }\n  }, {\n    key: \"onTabSelected\",\n    value: function onTabSelected(index) {\n      var _this$props$onTabSele, _this$props2;\n\n      (_this$props$onTabSele = (_this$props2 = this.props).onTabSelected) == null ? void 0 : _this$props$onTabSele.call(_this$props2, index);\n    }\n  }, {\n    key: \"renderTabBar\",\n    value: function renderTabBar() {\n      var _this$props3 = this.props,\n          height = _this$props3.height,\n          _this$props3$backgrou = _this$props3.backgroundColor,\n          backgroundColor = _this$props3$backgrou === void 0 ? DEFAULT_BACKGROUND_COLOR : _this$props3$backgrou,\n          containerView = _this$props3.containerView,\n          containerProps = _this$props3.containerProps,\n          gradientMargins = _this$props3.gradientMargins;\n      var scrollEnabled = this.state.scrollEnabled;\n      var containerHeight = height || DEFAULT_HEIGHT;\n      return _jsx(ScrollBar, {\n        ref: this.scrollBar,\n        contentContainerStyle: styles.scrollBarContainer,\n        scrollEnabled: scrollEnabled,\n        scrollEventThrottle: 16,\n        onScroll: this.onScroll,\n        onContentSizeChange: this.onContentSizeChange,\n        height: containerHeight,\n        gradientColor: backgroundColor,\n        containerView: containerView,\n        containerProps: containerProps,\n        gradientMargins: gradientMargins,\n        children: _jsx(View, {\n          row: true,\n          style: [styles.tabBar, {\n            height: containerHeight,\n            backgroundColor: backgroundColor\n          }],\n          children: this.renderChildren()\n        })\n      });\n    }\n  }, {\n    key: \"renderChildren\",\n    value: function renderChildren() {\n      var _this3 = this;\n\n      this.itemsRefs = [];\n      var _this$props4 = this.props,\n          indicatorStyle = _this$props4.indicatorStyle,\n          darkTheme = _this$props4.darkTheme;\n      var children = React.Children.map(this.props.children, function (child, index) {\n        var accessLabel = (child == null ? void 0 : child.props.accessibilityLabel) || child.props.label || '';\n        return React.cloneElement(child, {\n          indicatorStyle: indicatorStyle,\n          darkTheme: darkTheme,\n          selected: _this3.shouldBeMarked(index),\n          onPress: function onPress() {\n            _this3.onItemPress(index, child.props);\n          },\n          ref: function ref(r) {\n            _this3.itemsRefs[index] = r;\n          },\n          accessibilityLabel: accessLabel + \" \" + (index + 1) + \" out of \" + _this3.childrenCount\n        });\n      });\n      return children;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props5 = this.props,\n          enableShadow = _this$props5.enableShadow,\n          style = _this$props5.style,\n          _this$props5$backgrou = _this$props5.backgroundColor,\n          backgroundColor = _this$props5$backgrou === void 0 ? DEFAULT_BACKGROUND_COLOR : _this$props5$backgrou;\n      return _jsx(View, {\n        useSafeArea: true,\n        style: [styles.container, enableShadow && styles.containerShadow, style, {\n          height: undefined,\n          width: this.scrollContainerWidth,\n          backgroundColor: backgroundColor\n        }],\n        children: this.renderTabBar()\n      });\n    }\n  }]);\n\n  return TabBar;\n}(Component);\n\nTabBar.propTypes = {\n  enableShadow: _pt.bool,\n  minTabsForScroll: _pt.number,\n  selectedIndex: _pt.number,\n  onChangeIndex: _pt.func,\n  onTabSelected: _pt.func,\n  height: _pt.number,\n  containerWidth: _pt.number,\n  backgroundColor: _pt.string,\n  darkTheme: _pt.bool,\n  children: _pt.node,\n  testID: _pt.string\n};\nTabBar.displayName = 'TabBar';\nTabBar.defaultProps = {\n  selectedIndex: 0\n};\nTabBar.Item = TabBarItem;\nexport default asBaseComponent(TabBar);\nvar styles = StyleSheet.create({\n  container: {\n    zIndex: 100\n  },\n  containerShadow: _objectSpread({}, Platform.select({\n    ios: {\n      shadowColor: Colors.grey10,\n      shadowOpacity: 0.05,\n      shadowRadius: 2,\n      shadowOffset: {\n        height: 6,\n        width: 0\n      }\n    },\n    android: {\n      elevation: 5,\n      backgroundColor: Colors.white\n    }\n  })),\n  tabBar: {\n    flex: 1\n  },\n  shadowImage: {\n    width: '100%'\n  },\n  scrollBarContainer: {\n    minWidth: '100%'\n  }\n});","map":{"version":3,"sources":["/Users/aliabji/code/dogs/Pawls/node_modules/react-native-ui-lib/src/components/tabBar/index.js"],"names":["_pt","_","React","Component","Colors","Constants","asBaseComponent","LogService","View","ScrollBar","TabBarItem","MIN_TABS_FOR_SCROLL","DEFAULT_BACKGROUND_COLOR","white","DEFAULT_HEIGHT","TabBar","props","shouldBeMarked","index","state","currentIndex","isIgnored","childrenCount","onItemPress","updateIndicator","setTimeout","ignore","onChangeIndex","onTabSelected","onPress","onScroll","event","contentOffset","nativeEvent","onContentSizeChange","width","scrollContentWidth","minTabsForScroll","minChildrenCount","hasOverflow","setState","scrollEnabled","selectedIndex","x","y","scrollBar","createRef","itemsRefs","componentDeprecationWarn","oldComponent","newComponent","prevProps","prevState","prevChildrenCount","Children","count","children","isIndexManuallyChanged","containerWidth","screenWidth","child","toArray","get","scrollContainerWidth","undefined","scrollToSelected","animated","childRef","childLayout","getLayout","current","scrollTo","height","backgroundColor","containerView","containerProps","gradientMargins","containerHeight","styles","scrollBarContainer","tabBar","renderChildren","indicatorStyle","darkTheme","map","accessLabel","accessibilityLabel","label","cloneElement","selected","ref","r","enableShadow","style","container","containerShadow","renderTabBar","propTypes","bool","number","func","string","node","testID","displayName","defaultProps","Item","StyleSheet","create","zIndex","Platform","select","ios","shadowColor","grey10","shadowOpacity","shadowRadius","shadowOffset","android","elevation","flex","shadowImage","minWidth"],"mappings":"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","sourcesContent":["import _pt from \"prop-types\";\nimport _ from 'lodash';\nimport React, { Component } from 'react';\nimport { Platform, StyleSheet } from 'react-native';\nimport { Colors } from \"../../style\";\nimport { Constants, asBaseComponent } from \"../../commons/new\";\nimport { LogService } from \"../../services\";\nimport View from \"../view\";\nimport ScrollBar from \"../scrollBar\";\nimport TabBarItem from \"./TabBarItem\";\nconst MIN_TABS_FOR_SCROLL = 1;\nconst DEFAULT_BACKGROUND_COLOR = Colors.white;\nconst DEFAULT_HEIGHT = 48;\n\n/**\n * @description: TabBar Component\n * @modifiers: alignment, flex, padding, margin, background, typography, color (list of supported modifiers)\n * @example: https://github.com/wix/react-native-ui-lib/blob/master/demo/src/screens/componentScreens/TabBarScreen.tsx\n * @extends: ScrollBar\n * @notes: This is screen width component.\n */\nclass TabBar extends Component {\n  static propTypes = {\n    /**\n       * Show Tab Bar bottom shadow\n       */\n    enableShadow: _pt.bool,\n\n    /**\n       * The minimum number of tabs to render in scroll mode\n       */\n    minTabsForScroll: _pt.number,\n\n    /**\n       * current selected tab index\n       */\n    selectedIndex: _pt.number,\n\n    /**\n       * callback for when index has change (will not be called on ignored items)\n       */\n    onChangeIndex: _pt.func,\n\n    /**\n       * callback for when tab selected\n       */\n    onTabSelected: _pt.func,\n\n    /**\n       * Tab Bar height\n       */\n    height: _pt.number,\n\n    /**\n       * Pass when container width is different than the screen width\n       */\n    containerWidth: _pt.number,\n\n    /**\n       * The background color\n       */\n    backgroundColor: _pt.string,\n\n    /**\n       * set darkTheme style\n       */\n    darkTheme: _pt.bool,\n    children: _pt.node,\n    testID: _pt.string\n  };\n  static displayName = 'TabBar';\n  static defaultProps = {\n    selectedIndex: 0\n  };\n  static Item = TabBarItem;\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      scrollEnabled: false,\n      currentIndex: props.selectedIndex || 0\n    };\n    this.contentOffset = {\n      x: 0,\n      y: 0\n    };\n    this.scrollBar = React.createRef();\n    this.itemsRefs = [];\n    LogService.componentDeprecationWarn({\n      oldComponent: 'TabBar',\n      newComponent: 'TabController'\n    });\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    const prevChildrenCount = React.Children.count(prevProps.children);\n\n    if (this.childrenCount !== prevChildrenCount) {\n      this.updateIndicator(0);\n    } // TODO: since we're implementing an uncontrolled component here, we should verify the selectedIndex has changed\n    // between this.props and nextProps (basically the meaning of selectedIndex should be initialIndex)\n\n\n    const isIndexManuallyChanged = this.props.selectedIndex !== prevState.currentIndex && prevProps.selectedIndex !== this.props.selectedIndex;\n\n    if (isIndexManuallyChanged) {\n      this.updateIndicator(this.props.selectedIndex);\n    }\n  } // generateStyles() {\n  //   this.styles = createStyles(this.props);\n  // }\n\n\n  get childrenCount() {\n    return React.Children.count(this.props.children);\n  }\n\n  get scrollContainerWidth() {\n    return this.props.containerWidth || Constants.screenWidth;\n  }\n\n  isIgnored(index) {\n    const child = React.Children.toArray(this.props.children)[index];\n    return _.get(child, 'props.ignore');\n  }\n\n  hasOverflow() {\n    return this.scrollContentWidth && this.scrollContentWidth > this.scrollContainerWidth;\n  }\n\n  shouldBeMarked = index => {\n    return this.state.currentIndex === index && !this.isIgnored(index) && this.childrenCount > 1;\n  };\n\n  updateIndicator(index) {\n    if (index !== undefined && !this.isIgnored(index)) {\n      this.setState({\n        currentIndex: index\n      }, () => {\n        this.scrollToSelected();\n      });\n    }\n  }\n\n  scrollToSelected(animated = true) {\n    const childRef = this.itemsRefs[this.state.currentIndex];\n    const childLayout = childRef.getLayout();\n\n    if (childLayout && this.hasOverflow()) {\n      if (childLayout.x + childLayout.width - this.contentOffset.x > this.scrollContainerWidth) {\n        this.scrollBar?.current?.scrollTo?.({\n          x: childLayout.x - this.scrollContainerWidth + childLayout.width,\n          y: 0,\n          animated\n        });\n      } else if (childLayout.x - this.contentOffset.x < 0) {\n        this.scrollBar?.current?.scrollTo?.({\n          x: childLayout.x,\n          y: 0,\n          animated\n        });\n      }\n    }\n  }\n\n  onChangeIndex(index) {\n    this.props.onChangeIndex?.(index);\n  }\n\n  onTabSelected(index) {\n    this.props.onTabSelected?.(index);\n  }\n\n  onItemPress = (index, props) => {\n    this.updateIndicator(index);\n    setTimeout(() => {\n      if (!props.ignore) {\n        this.onChangeIndex(index);\n      }\n\n      this.onTabSelected(index);\n      props.onPress?.();\n    }, 0);\n  };\n  onScroll = event => {\n    const {\n      contentOffset\n    } = event.nativeEvent;\n    this.contentOffset = contentOffset;\n  };\n  onContentSizeChange = width => {\n    if (this.scrollContentWidth !== width) {\n      this.scrollContentWidth = width;\n      const {\n        minTabsForScroll\n      } = this.props;\n      const minChildrenCount = minTabsForScroll || MIN_TABS_FOR_SCROLL;\n\n      if (this.hasOverflow() && this.childrenCount > minChildrenCount) {\n        this.setState({\n          scrollEnabled: true\n        });\n      }\n    }\n  };\n\n  renderTabBar() {\n    const {\n      height,\n      backgroundColor = DEFAULT_BACKGROUND_COLOR,\n      containerView,\n      containerProps,\n      gradientMargins\n    } = this.props;\n    const {\n      scrollEnabled\n    } = this.state;\n    const containerHeight = height || DEFAULT_HEIGHT;\n    return <ScrollBar // @ts-ignore\n    ref={this.scrollBar} contentContainerStyle={styles.scrollBarContainer} scrollEnabled={scrollEnabled} scrollEventThrottle={16} onScroll={this.onScroll} onContentSizeChange={this.onContentSizeChange} height={containerHeight} gradientColor={backgroundColor} containerView={containerView} containerProps={containerProps} gradientMargins={gradientMargins}>\n        <View row style={[styles.tabBar, {\n        height: containerHeight,\n        backgroundColor\n      }]}>\n          {this.renderChildren()}\n        </View>\n      </ScrollBar>;\n  }\n\n  renderChildren() {\n    this.itemsRefs = [];\n    const {\n      indicatorStyle,\n      darkTheme\n    } = this.props;\n    const children = React.Children.map(this.props.children, (child, index) => {\n      // @ts-ignore\n      const accessLabel = child?.props.accessibilityLabel || child.props.label || ''; //TODO: review it again, all types here should be correct. As from React.Children.map it gets definitely child: React.ReactNode, and React.cloneElement does not accept it.\n      // But seems it's work in a real life, so maybe it is just trouble with types compatibility\n      //@ts-ignore\n\n      return React.cloneElement(child, {\n        indicatorStyle,\n        darkTheme,\n        selected: this.shouldBeMarked(index),\n        onPress: () => {\n          // @ts-ignore\n          this.onItemPress(index, child.props);\n        },\n        ref: r => {\n          this.itemsRefs[index] = r;\n        },\n        accessibilityLabel: `${accessLabel} ${index + 1} out of ${this.childrenCount}`\n      });\n    });\n    return children;\n  }\n\n  render() {\n    const {\n      enableShadow,\n      style,\n      backgroundColor = DEFAULT_BACKGROUND_COLOR\n    } = this.props;\n    return (// @ts-ignore\n      <View useSafeArea style={[styles.container, enableShadow && styles.containerShadow, style, {\n        height: undefined,\n        width: this.scrollContainerWidth,\n        backgroundColor\n      }]}>\n        {this.renderTabBar()}\n      </View>\n    );\n  }\n\n}\n\nexport default asBaseComponent(TabBar);\nconst styles = StyleSheet.create({\n  container: {\n    zIndex: 100\n  },\n  containerShadow: { ...Platform.select({\n      ios: {\n        shadowColor: Colors.grey10,\n        shadowOpacity: 0.05,\n        shadowRadius: 2,\n        shadowOffset: {\n          height: 6,\n          width: 0\n        }\n      },\n      android: {\n        elevation: 5,\n        backgroundColor: Colors.white\n      }\n    })\n  },\n  tabBar: {\n    flex: 1\n  },\n  shadowImage: {\n    width: '100%'\n  },\n  scrollBarContainer: {\n    minWidth: '100%'\n  }\n});"]},"metadata":{},"sourceType":"module"}